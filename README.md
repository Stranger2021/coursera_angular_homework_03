# coursera_angular_homework_03

Общая Идея

Вы собираетесь построить значительно упрощенный поиск описаний пунктов меню, используя ресторанный сервер REST API, который мы использовали в лекции 25, Часть 2.

Идея здесь заключается в том, чтобы пользователь искал описания пунктов меню. Затем, учитывая список совпадений его поиска, дайте пользователю возможность выбрасывать элементы, которые они наверняка не хотят из списка, таким образом сужая его до того, что они действительно хотят.

Ваша задача-создать текстовое поле и кнопку с надписью "Narrow It Down For Me!".

Сначала пользователь должен просто увидеть экран с текстовым полем и кнопкой "Narrow It Down For Me!". Как только пользователь вводит что-то в текстовое поле и нажимает кнопку, ваше приложение обращается к серверу и извлекает список пунктов меню для всего меню. После извлечения ваша задача состоит в том, чтобы перебрать все элементы и для каждого элемента выполнить простую проверку, появляется ли искомая пользователем строка в любом месте описания элемента. Если это так, то этот элемент помещается в специальный found массив. Если нет, вы просто переходите к следующему пункту.

После того, как ваше приложение проходит через все элементы, он должен отображать found список элементов. Каждый элемент списка должен содержать имя элемента меню, его short_name и описание. Вы можете отобразить элементы в простом неупорядоченном списке, причем каждый элемент информации разделяется запятой. Или быть причудливее и использовать какую-то сетку. В любом случае это нормально. Мы не концентрируемся на стиле в этом классе.
Вы также должны предоставить кнопку "Don't want this one!" рядом с каждым элементом в списке, чтобы дать пользователю возможность удалить элемент из этого списка.

Если в результате поиска ничего не найдено или пользователь оставляет текстовое поле пустым и нажимает кнопку "Narrow It Down For Me!", вы должны просто отобразить сообщение "Nothing found".

Чтобы сделать вещи немного проще, вы можете получить элементы с сервера каждый раз, когда пользователь нажимает кнопку "Narrow It Down For Me!". Вам не нужно кэшировать ответ. Другими словами, независимо от того, какие действия пользователь предпринял, если нажата кнопка "Narrow It Down For Me!", все данные стираются, и весь процесс начинается снова. Нет необходимости помнить, что пользователь решил выбросить из списка в прошлый раз.

Правила
Нарушение одного из этих правил приведет к тому, что вы не справитесь с заданием:

Вы не можете использовать обычный onclick атрибут HTML для привязки поведения к кнопке. 
Вы должны использовать AngularJS-способ поведения привязки.

Ни в коем случае ваш Javascript-код не должен искать что-либо в DOM браузера.


Шаги
Вот что вам нужно будет сделать, чтобы выполнить задание:

Шаги по реализации требований назначения
Объявите ng-app либо на html элементе, либо на body элементе. Назовите свое приложение NarrowItDownApp.

Создайте app.js в своем проекте и объявите угловой модуль, соответствующий вашему ng-app объявлению.

Объявите и создайте контроллер NarrowItDownController (с контроллером в качестве синтаксиса), который будет обертывать текстовое поле поиска и кнопку, а также список найденных элементов.

Объявите и создайте MenuSearchService. Сервис должен иметь следующий метод: getMatchedMenuItems(searchTerm). Этот метод будет отвечать за обращение к серверу (используя службу $http) для получения списка всех пунктов меню. Как только он получит все пункты меню, он должен перебрать их, чтобы выбрать те, чье описание соответствует поисковому термину. Как только список найденных элементов будет скомпилирован, он должен вернуть этот список (завернутый в обещание). Помните, что сама then-функция возвращает обещание. Ваш метод примерно будет выглядеть так:

NarrowItDownController должен быть введен вместе с MenuSearchService. Контроллер должен вызвать метод getMatchedMenuItems, когда это необходимо, и сохранить результат в свойстве, называемом found присоединенным к экземпляру контроллера.

Объявите и создайте foundItems директиву. Список должен быть отображен с помощью этого directive, который принимает found массив элементов, указанных на нем в качестве атрибута (думаю, односторонняя привязка с 'Для реализации функциональности кнопки "Не хочу этого!" директива также должна содержать атрибут on-remove, который будет использовать привязку ссылок на функции для вызова родительского контроллера удаление элемента из found массива на основе индекса в поле found массив. Индекс должен быть передан из директивы в контроллер. (Обратите внимание, что мы реализовали почти идентичный тип поведения в лекции 30 Часть 2, так что пока вы понимаете этот код, он должен быть очень близок к copy/paste). В узконаправленном контроллере просто удалите этот элемент из found массива. Это можно сделать с помощью метода splice() массива. Например, чтобы удалить элемент с индексом 3 из found массива, вы должны вызвать found.splice(3, 1);.

Важные замечания по внедрению

Убедитесь, что весь ваш Javascript-код находится внутри IIFE. (Если вы не знаете, что это такое и почему мы хотим его использовать, освежите его в памяти, просмотрев модуль 4 курса HTML, CSS и Javascript для веб-разработчиков, который я преподаю.)

Убедитесь, что все ваши инъекции зависимости защищены от минификации.

После того, как вы закончите и будете удовлетворены вашим решением, не забудьте добавить/зафиксировать/отправить свой код в репозиторий.
